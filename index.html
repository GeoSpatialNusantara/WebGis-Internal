<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<title>WebGIS - GeoSpatialNusantara</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
body{margin:0;font-family:Arial}
#map{height:100vh;width:100%}

/* ================= SIDEBAR ================= */
#sidebar{
position:fixed;
top:0;
right:0;
width:370px;
height:100%;
background:#f4f4f4;
box-shadow:-3px 0 10px rgba(0,0,0,.2);
transform:translateX(100%);
transition:.3s;
z-index:1000;
overflow:hidden;
}
#sidebar.active{transform:translateX(0)}

#toggleBtn{
position:fixed;
top:15px;
right:15px;
z-index:2000;
padding:8px 12px;
border:none;
border-radius:6px;
background:white;
cursor:pointer;
box-shadow:0 2px 6px rgba(0,0,0,.2);
transition:right .3s ease;
}

/* ================= TABS ================= */
.tabs{display:flex;background:#e0e0e0}
.tab{flex:1;padding:10px;text-align:center;cursor:pointer;font-weight:bold}
.tab.active{background:white;border-bottom:3px solid #2c7be5}
.tab-content{display:none;padding:15px;height:calc(100% - 45px);overflow:auto}
.tab-content.active{display:block}

/* ================= ROW ================= */
.row{display:flex;align-items:center;margin-top:8px}
.arrow{margin-right:6px;cursor:pointer;transition:.3s}
.arrow.rotate{transform:rotate(90deg)}

.toggle{
width:16px;height:16px;border-radius:50%;
background:#bbb;margin-right:8px;cursor:pointer;
transition:.2s;
}
.toggle.active{background:#2c7be5}

.year-container{display:none;margin-left:20px}

input{
width:100%;padding:8px;margin-bottom:10px;
border-radius:6px;border:1px solid #ccc;
}

.leaflet-control-layers label {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
}

.leaflet-control-layers input {
    margin: 0;
}

#searchResult div{
padding:6px;
background:white;
margin-bottom:4px;
border-radius:6px;
cursor:pointer;
border:1px solid #ddd;
}

#searchResult div:hover{
background:#2c7be5;
color:white;
}
    
</style>
</head>

<body>

<div id="map"></div>
<button id="toggleBtn">☰</button>

<div id="sidebar">

<div class="tabs">
<div class="tab active" data-tab="layerTab">Layer</div>
<div class="tab" data-tab="uploadTab">Upload</div>
</div>

<div id="layerTab" class="tab-content active">

<input type="text" id="searchInput" placeholder="Cari file... (contoh: 2023, jalan, sulawesi)">
<div id="searchResult" style="margin-bottom:15px;"></div>

<div id="layerList"></div>

</div>

<div id="uploadTab" class="tab-content">
<input type="file" id="uploadInput" multiple accept=".zip,.kml,.kmz">
<hr>
<div id="uploadList"></div>
</div>

</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/shpjs@latest/dist/shp.min.js"></script>
<script src="https://unpkg.com/leaflet-omnivore@latest/leaflet-omnivore.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
const OWNER="GeoSpatialNusantara";
const REPO="WebGis";
const BRANCH="main";
const ROOT="file";
const markerImage=`https://raw.githubusercontent.com/${OWNER}/${REPO}/${BRANCH}/img/point-of-interest.png`;

const map = L.map('map', {
    minZoom: 5,     // tidak bisa zoom out lebih jauh dari Indonesia
    maxZoom: 18     // tetap bisa zoom in detail
}).setView([-2.5,118],5);
    
// Basemap OSM (default)
const osm = L.tileLayer(
    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    { attribution: '© OpenStreetMap' }
);

// Basemap Satellite Hybrid (Satelit + Label)
const satellite = L.layerGroup([
    L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        { attribution: 'Tiles © Esri' }
    ),
    L.tileLayer(
        'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
        { attribution: 'Labels © Esri' }
    )
]);

// tampilkan default
osm.addTo(map);

// kontrol layer (pojok kiri atas)
L.control.layers(
    {
        "One Street Map": osm,
        "Satellite": satellite
    },
    null,
    { position: 'topleft' }
).addTo(map);

toggleBtn.onclick=()=>{
sidebar.classList.toggle("active");
if(sidebar.classList.contains("active")){
toggleBtn.style.right="385px";
}else{
toggleBtn.style.right="15px";
}
};

document.querySelectorAll(".tab").forEach(tab=>{
tab.onclick=function(){
document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
document.querySelectorAll(".tab-content").forEach(c=>c.classList.remove("active"));
tab.classList.add("active");
document.getElementById(tab.dataset.tab).classList.add("active");
};
});

let layerStore={};

const searchInput = document.getElementById("searchInput");
const searchResult = document.getElementById("searchResult");

searchInput.addEventListener("input", function(){

    const keyword = this.value.toLowerCase();
    searchResult.innerHTML="";

    if(keyword.length < 2){
        searchResult.innerHTML="";
        return;
    }

    for(let key in layerStore){

        const fileName = key.split("/").pop().toLowerCase();

        if(fileName.includes(keyword)){

            const item = document.createElement("div");
            item.innerText = key.split("/").pop();

            item.onclick = async function(){

                await loadLayer(key);

                const layer = layerStore[key].layer;

if(layer){
    const bounds = layer.getBounds();
    if(bounds && bounds.isValid()){
        map.fitBounds(bounds, {
            padding:[50,50],
            maxZoom:16
        });
    }
}

                // aktifkan toggle tahun otomatis
                document.querySelectorAll(".toggle").forEach(t=>{
                    if(!t.classList.contains("active")){
                        t.click();
                    }
                });

                searchResult.innerHTML="";
                searchInput.value="";
            };

            searchResult.appendChild(item);
        }
    }
});
    
async function fetchGitHub(path){
const url=`https://api.github.com/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
const res=await fetch(url);
return await res.json();
}

async function loadStructure(){
const container=document.getElementById("layerList");
const cats=await fetchGitHub(ROOT);

for(const cat of cats){
if(cat.type!=="dir") continue;

const row=document.createElement("div");
row.className="row";

const arrow=document.createElement("span");
arrow.className="arrow";
arrow.innerHTML="▶";

const catToggle=document.createElement("div");
catToggle.className="toggle";

const label=document.createElement("span");
label.innerText=cat.name;

row.append(arrow,catToggle,label);
container.appendChild(row);

const yearContainer=document.createElement("div");
yearContainer.className="year-container";
container.appendChild(yearContainer);

arrow.onclick=()=>{
yearContainer.style.display=
yearContainer.style.display==="block"?"none":"block";
arrow.classList.toggle("rotate");
};

let yearToggles=[];

catToggle.onclick=async(e)=>{
e.stopPropagation();
catToggle.classList.toggle("active");
const active=catToggle.classList.contains("active");

for(const y of yearToggles){
if(active && !y.classList.contains("active")) await y.click();
if(!active && y.classList.contains("active")) await y.click();
}
};

const years=await fetchGitHub(cat.path);

for(const year of years){
if(year.type!=="dir") continue;

const yRow=document.createElement("div");
yRow.className="row";

const yToggle=document.createElement("div");
yToggle.className="toggle";

const yLabel=document.createElement("span");
yLabel.innerText=year.name;

yRow.append(yToggle,yLabel);
yearContainer.appendChild(yRow);

yearToggles.push(yToggle);

const files=await fetchGitHub(year.path);
for(const file of files){
if(!file.name.match(/\.(zip|kml|kmz)$/i)) continue;
layerStore[file.path]={url:file.download_url,layer:null,marker:null};
}

yToggle.onclick=()=>toggleYear(year.path,yToggle);
}
}
}

async function toggleYear(path,toggle){
toggle.classList.toggle("active");
const active=toggle.classList.contains("active");

for(let key in layerStore){
if(key.startsWith(path)){
if(active) await loadLayer(key);
else{
if(layerStore[key].layer) map.removeLayer(layerStore[key].layer);
if(layerStore[key].marker) map.removeLayer(layerStore[key].marker);
}
}
}
}

function addCenterMarker(layer,key){

    const bounds = layer.getBounds();
    if(!bounds || !bounds.isValid()) return;

    const center = bounds.getCenter();

    const icon = L.icon({
        iconUrl: markerImage,
        iconSize: [30,30],
        iconAnchor: [15,30]
    });

    if(layerStore[key].marker){
        map.removeLayer(layerStore[key].marker);
    }

    const fileName = key.split("/").pop();
    const fileUrl = layerStore[key].url;

    const marker = L.marker(center,{icon}).addTo(map);

    // isi popup dengan nama + link download
    const popupContent = `
        <div style="text-align:center;">
            <b>${fileName}</b><br>
            <a href="${fileUrl}" download style="color:#2c7be5;text-decoration:none;font-weight:bold;">
                Download
            </a>
        </div>
    `;

    marker.bindPopup(popupContent,{
    closeButton: false,
    autoClose: false,
    closeOnClick: false,
    offset:[0,-25]
});
let popupHovered = false;
let markerHovered = false;

marker.on("mouseover", function () {
    markerHovered = true;
    this.openPopup();
});

marker.on("mouseout", function () {
    markerHovered = false;
    setTimeout(() => {
        if (!popupHovered && !markerHovered) {
            marker.closePopup();
        }
    }, 200);
});

marker.on("click", function(){
    const bounds = layer.getBounds();
    if(bounds && bounds.isValid()){
        map.fitBounds(bounds, {
            padding:[50,50],
            maxZoom: 16
        });
    }
});

marker.on("popupopen", function () {
    const popupEl = marker.getPopup().getElement();

    if (!popupEl._hoverBound) {

        popupEl.addEventListener("mouseenter", function () {
            popupHovered = true;
        });

        popupEl.addEventListener("mouseleave", function () {
            popupHovered = false;
            setTimeout(() => {
                if (!popupHovered && !markerHovered) {
                    marker.closePopup();
                }
            }, 200);
        });

        popupEl._hoverBound = true;
    }
});

    layerStore[key].marker = marker;

}
  
async function loadLayer(key){
if(layerStore[key].layer){
map.addLayer(layerStore[key].layer);
if(layerStore[key].marker) map.addLayer(layerStore[key].marker);

return;
}

let layer;

if(layerStore[key].url.endsWith(".zip")){
const res=await fetch(layerStore[key].url);
const buffer=await res.arrayBuffer();
const geo=await shp(buffer);
layer = L.geoJSON(geo, {
    pointToLayer: function () {
        return null; // jangan tampilkan marker asli
    }
}).addTo(map);

}else if(layerStore[key].url.endsWith(".kmz")){
const res=await fetch(layerStore[key].url);
const buffer=await res.arrayBuffer();

const zip=await JSZip.loadAsync(buffer);
let kmlFile;

zip.forEach((relativePath, zipEntry)=>{
if(relativePath.endsWith(".kml")){
kmlFile=zipEntry;
}
});

if(kmlFile){
const kmlText=await kmlFile.async("text");
layer = omnivore.kml.parse(kmlText);
layer.on("ready", function(){
    layer.eachLayer(function(l){
        if(l instanceof L.Marker){
            layer.removeLayer(l);
        }
    });
});
layer.addTo(map);
}

}else{
layer = omnivore.kml(layerStore[key].url);
layer.on("ready", function(){
    layer.eachLayer(function(l){
        if(l instanceof L.Marker){
            layer.removeLayer(l);
        }
    });
});
layer.addTo(map);
    
}
    
layerStore[key].layer=layer;

if(layer instanceof L.GeoJSON){
addCenterMarker(layer,key);
}else{
layer.on("ready",()=>{
addCenterMarker(layer,key);
});
}

}
  
/* ================= UPLOAD ================= */
uploadInput.addEventListener("change",async e=>{
for(const file of e.target.files){

let layer;
if(file.name.endsWith(".zip")){
const buffer=await file.arrayBuffer();
const geo=await shp(buffer);
layer=L.geoJSON(geo);
}else if(file.name.endsWith(".kmz")){
const buffer=await file.arrayBuffer();
const zip=await JSZip.loadAsync(buffer);

let kmlFile;
zip.forEach((relativePath, zipEntry)=>{
if(relativePath.endsWith(".kml")){
kmlFile=zipEntry;
}
});

if(kmlFile){
const kmlText=await kmlFile.async("text");
layer=omnivore.kml.parse(kmlText);
}

}else{
layer=omnivore.kml.parse(await file.text());
}

const key="upload_"+Date.now()+file.name;
layerStore[key]={layer:layer,marker:null};

const row=document.createElement("div");
row.className="row";

const toggle=document.createElement("div");
toggle.className="toggle active";

const label=document.createElement("span");
label.innerText=file.name;

row.append(toggle,label);
uploadList.appendChild(row);

toggle.onclick=()=>{
toggle.classList.toggle("active");
if(toggle.classList.contains("active")){
layer.addTo(map);
map.fitBounds(layer.getBounds());
}else{
map.removeLayer(layer);
}
};

toggle.click();
}
});

loadStructure();
</script>

</body>
</html>
